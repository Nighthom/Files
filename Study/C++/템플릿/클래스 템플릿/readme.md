# 클래스 템플릿

>> 클래스 템플릿은.. 어떠한 타입을 비워두고,     
>> 그 타입이 들어갈 자리에 여러가지 타입을 박아넣어서    
>> 똑같은 내용의 클래스를 타입만 바꿔서 찍어내는 개념입니다.    

>> 제네릭이랑 비슷한데, 제네릭은 런타임에 타입이 결정된다면,  
>> 템플릿은 그냥 컴파일 타임에 여러가지 함수나 클래스들을 찍어주고,  
>> 템플릿 함수 호출이나 템플릿 클래스 접근 시에 이름만 싹 바꿔서  
>> 전달해주는 식으로 구현합니다.  

>> 문법은 굉장히 간단합니다.  
```C++
template<typename T>
class A {
public:
  A(){}
  ~A(){}
private:
  T m_tData;
};
int main() {
  A<int> a;     // 템플릿 클래스는 이런식으로 타입을 명시해주어야 함.
  A<double> b;
  return 0;
}
```
>> 이러면 int형 m_tData를 가진 인스턴스 a와,  
>> double형 m_tData를 가진 인스턴스 b가 생성됩니다.  
>> 구현 원리는? 컴파일 타임에 생성될 타입의 갯수만큼  
>> 템플릿을 찍어놓는 거죠.   
```C++
template<typename T1, typename T2>
```
>> 이런식으로 여러가지를 지정해 줄 수도 있습니다.  

## 템플릿 매개변수
```C++
template<typename T, int nSize>
class A {
  ....
}
int main() {
  A<int, 3>;
  return 0;
}
```
>> 템플릿 매개변수는 함수의 매개변수처럼 템플릿을 활용할 수 있게 해주는겁니다.  
>> 템플릿 타입의 클래스를 선언할 때, 입력해주면 매개변수처럼 작용합니다.  
>> nSize의 값으로 3을 전달했고,  이 3이란 값을 어떻게 쓰는지는  
>> 클래스 작성자의 마음인 거죠.  
>> 뭐.. int형 3칸짜리 배열을 동적할당으로 써도 됩니다.  
>> new로 int형 인스턴스 배열을 생성하는데 3의 사이즈로 생성해주고,  
>> delete로 나중에 지워주고.. 하면 되니까요.   

