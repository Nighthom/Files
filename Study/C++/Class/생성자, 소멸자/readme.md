# 생성자  
```C++
class Data {
  int nData[10];
  int data_size;
  
  Data() {
    data_size = 0;
  }
  Data(int Data[], int size) {
    for(int i(0); i<size; i++)
      nData[i] = Data[i];
    data_size = size;
  }
}
```
>> 위 코드에서 Data() 함수가 바로 생성자입니다.  
>> void형 반환형을 기본적으로 갖고, 전달인자를 받을 수 있으며, 
>> 객체가 생성됨과 동시에 호출되어서, 적절한 값을 초기화합니다.  
>> 만약 생성자를 정의하지 않았다면, "아무 내용도 없는" 생성자를 자동으로 만들어서  
>> 호출하게 되는 겁니다.  
>> 새롭게 생성된 Data의 사이즈가 0이므로, 바로 생성자로 초기화할 수 있습니다.    
>> 사용자는 data_size에 대해서 그 어떠한 관리도 할 필요 없고,    
>> 단순히 생성만 해도 자동으로 초기화가 되고, 관리도 할 수 있겠죠?   
>> 생성자는 프로그래머에게 고도의 추상적 인터페이스를 제공해 줄 수 있는  
>> 하나의 장치입니다.  
>> 또한, 생성자가 전달받는 인자는 인스턴스를 만들 때  
>> 함수 호출하듯이 전달해 줄 수 있습니다.
>> 그리고 생성자도 서로 다른 인자를 받아서 오버로딩할 수 있는데,   
>> 아래 생성자의 경우, 
```C++
Data D( {1, 2, 3, 4, 5}, 5) );
```
>> 를 전달하면 아래 생성자가 실행되는 식입니다.

>> 변수 선언 시 사용하는 문법 중 하나로 int a = 0; 이 아닌 int a(0); 을 사용할 수 있습니다.   
>> 이는 변수도 "생성자"를 통해서 초기화하는 느낌이 강하죠?   
>> 이가 시사하는 점은 int형 변수 또한 생성자를 갖는 "객체"라는 느낌을 강하게 받으실 수 있다는 것이죠.  
>> 물론 C에서도 이것은 객체였고, C++에 와서도 달라지진 않았습니다만,  
>> "생성자"를 갖는 "인스턴스" 느낌을 주는 선언입니다.  
>> 물론, 컴파일러는 int a = 0;과 int a(0);을 동일하게 해석하겠지만..  

## 생성자 초기화 목록
```C++
class Student {
  char* name;
  int grade;
  
  Student() 
  : name("Yoon"), grade(3)
  { }
}
```
>> 이런 식으로 생성자를 호출할 코드와 변수의 정의를 분리할 수도 있습니다.    
>> 이를 문법적으로 지원합니다. 이렇게 정의하면 생성자 실행 전에  
>> 멤버 변수들을 초기화할 수 있습니다.  

## C++11부터 지원하는 기능
```C++
class Student {
  char* name = "Yoon";
  int grade = 3;
  
  Student() { }
```
>> 위 기능은 멤버 변수를 선언과 동시에 초기화하는 문법입니다.    
>> 생성자가 없이도 알아서 초기화해주죠. 생성자가 호출되기 전에  
>> 초기화가 됩니다.  

>> 생성자 관련된 흥미로운 이야기가 하나 있는데,  
>> Student형 인스턴스를 가지는 전역 인스턴스 하나를 선언할 경우
>> 이는 main함수보다 먼저 호출될 수도 있습니다.  
>> main함수는 프로그램의 하나의 분기일 뿐, 프로그램의 "모든 것"은   
>> 아니라는 것을 시사하는 바죠.  
>> 결국 Copiler Stub Code에서 호출해주는 하나의 함수.. 인 것일 뿐입니다.  

# 소멸자  
>> 생성자는 인스턴스의 생성과 동시에 실행되는 함수라면,  
>> 소멸자는 인스턴스의 소멸과 함께 실행되는 함수입니다.  
```C++
class Test {
  Test() {
    std::cout << "Test()\n" << endl;
  }
  ~Test() {
    std:cout << "~Test()\n" << endl;
  }
}
```
>> ~Test 함수가 소멸자입니다.  
>> 인스턴스는 해당 인스턴스가 선언된 스코프 안에 있는동안 생존해있고,  
>> 스코프를 벗어나는 순간 자동으로 해제됩니다.  
>> C언어 스타일로 말하자면 스택 프레임 같은 개념인거죠.  
>> main()함수에서 생성한 인스턴스는   
>> main() 함수가 끝남과 동시에 해제되므로,  
>> 아래 코드는 다음과 같은 결과를 도출합니다.  
```C++
int main() {
  std::cout << strat of main << endl;
  Test t;
  std::cout << end of main << endl;
  return 0;
}
```

```C++
output : 
strat of main
Test()
end of main
~Test()
```
>> 위 결과는 메인함수가 끝나고 나서도 소멸자가 호출된다는 것을 보여줍니다.  
