# 가상함수
>> virtual 키워드를 통해 정의합니다.  
>> 메서드 선언 시에  virtual, const, static 등의  키워드를 붙일 수 있는데,  
>> 앞에 붙여주면 됩니다.  
>> 가상함수의 개념은 무엇일까요? 우선, 미래에 재정의될 것을 기대하는  
>> 함수라고 보면 됩니다. 즉, 오버라이딩해줄 것이 기대되는 함수입니다.  
>> 자식 클래스에서 반드시 "오버라이딩" 해 줄 것이 기대된다는 것은,  
>> 미래의 코드 작성자에게 코드를 맡기는 것과도 같죠.  
>> 함수의 종류를 구분하자면, 
>> **일반 함수**  - 선언과 정의가 정상적으로 함께 존재합니다.  
>> **순수 가상 함수** - 선언만 존재합니다. 정의는 파생 클래스에서 해줄 것으로 기대합니다.  
>> **일반 가상 함수** - 선언과 정의가 존재하되, 재정의될 것을 기대합니다.  
>> 만약, 일반 가상함수를 정의한 클래스  A가 존재한다고 전제합니다.  
>> A의 상속을 받은 파생 클래스 B가 있을 때,  
>> B가 A의 가상함수를 오버라이딩했습니다.  
>> 이 때, A 타입 참조/포인터에 B의 인스턴스를 복사해서 넣었습니다.  
>> 일반 함수 A가 정의되어 있었다면 보통 참조나 포인터에 해당하는 형식으로  
>> 해당 클래스를 해석하기 때문에, 일반 클래스 A에 존재하는 함수를 호출하겠죠.  
>> 하지만, 가상 함수로 정의했다면 실형식인 파생 클래스 B의 메서드를 호출합니다.  
>> 제 아무리 해석형식을 A로 해주었다 해도 말이죠.  
```C++
class A { 
public:
  virtual void printData() {
    cout << "A::printData()" << endl;
  }  // 가상함수
virtual void print() = 0;     // 순수 
class B : public A {
  virtual void printData() {
    cout << "B::printData()" << endl;
}

int main() {
  B a;
  A &b = a;       // A의 포인터로 선언해도 됨.
  
  b.printData();
  return 0;
}
```
>> 위 코드의 기대 결과는  
>> B::printData()  일 것입니다.  
>> 접근 형식을 기준으로 생각하면 A의 함수가 호출되어야 맞겠습니다만,  
>> 가상 함수를 이용하면 실 형식을 기준으로 함수를 호출하게 되니까 말이죠.  

>> 만약 A의 함수가 가상 함수가 아니었다면,    
>> 참조 형식에 따라서 호출되었을 것입니다. 즉,    
>> A의 참조이므로 A의 함수가 호출되었겠죠.  

>> 즉, 가상함수는 실 형식을 따르고, 일반 함수는 참조 형식을 따라서 함수를 호출합니다.  

## 일반 가상함수, 순수 가상함수
  1. 일반 가상함수
    - 일반 가상함수는 몸체가 있는 가상함수입니다. 위에 적은 대로,  
    - 가상함수를 오버라이딩한 클래스가 실 형식일 경우  
    - 실 형식의 가상함수가 호출됩니다.  
  2. 순수 가상함수
    - 몸통이 비어있는 가상함수입니다. 미래에 재정의할 것을  
    - 완벽하게 요망하는 함수죠. 
>> 만약 일반 가상함수로 실행되어 있다면,  일반 클래스에 누군가가  
>> 그 가상함수의 몸통부분을 정의해놓은 것이겠죠.  
>> 그렇다면, 파생 클래스 몸통을 정의할 때 일반 클래스의  
>> 몸통 또한 불러줘도 괜찮을 겁니다. 
>> ex) 클래스 A의 파생 클래스 B가 존재할 때,  
>> 클래스 A에 가상메서드 getData가 존재한다.
>> 근데, B에서 받는 Data의 범주를 제한하고 싶어서 함수를 재정의했다.  
>> 0~10사이의 값을 받기로 했다.  
>> 그러면 상위 클래스의 가상함수를 몸통부분에서 "호출"해주고,  
>> 유효값 검사만 해서 잘라주면 되지 않을까?  

>> 이런 느낌인거죠. 그 상위 가상함수를 "언제", "어떻게"  
>> 호출할 지는 프로그래머의 자유인 거고요.  

## final(C++11)
>> 가상 함수를 쭉 상속해서, override하다가 특정 시점에서  
>> 가상함수의 override를 차단하고 싶다면,  해당 시점  
>> 클래스의 가상함수 선언에 final 키워드를 붙이면 됩니다.  
```C++
virtual int func() final;
```
>> 클래스에도 final을 붙여줄 수 있는데, 이러면 상속을 할 수 없습니다.  
```C++
class A final {

};
class B : public A {    // 빌드 에러!(final 클래스를 상속함)  

};
```

## override 키워드(C++11)
>> override 키워드는 가상 함수에만 붙여줄 수 있는 키워드고,  
>> 어떤 가상함수를 "오버라이드" 할 것이라고 명시해주는 것입니다.  
>> 예를 들어 매개변수로 전달해야 할 타입이 int인데 double이라고 잘못 적어서  
>> 본래 오버라이딩하려 했던 함수와 다른 함수를 정의하면 빌드 에러가 나지 않아요.  
>> 함수 다형성 때문입니다.  
>> 하지만 오버라이드 키워드를 붙여주면 빌드 에러가 납니다.  
>> 이는, 실수로 잘못 작성한 코드를 줄여줄 수 있습니다.  
```C++
class A {
protected:
  int print() override;
}
class B : public A {
  int print(int a)  override;   // 빌드 에러!
}
```
>> 이런 식으로 잘못된 정의를 피할 수 있는 좋은 습관입니다.  
