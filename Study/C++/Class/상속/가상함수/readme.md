# 가상함수
>> virtual 키워드를 통해 정의합니다.  
>> 메서드 선언 시에  virtual, const, static 등의  키워드를 붙일 수 있는데,  
>> 앞에 붙여주면 됩니다.  
>> 가상함수의 개념은 무엇일까요? 우선, 미래에 재정의될 것을 기대하는  
>> 함수라고 보면 됩니다. 즉, 오버라이딩해줄 것이 기대되는 함수입니다.  
>> 자식 클래스에서 반드시 "오버라이딩" 해 줄 것이 기대된다는 것은,  
>> 미래의 코드 작성자에게 코드를 맡기는 것과도 같죠.  
>> 함수의 종류를 구분하자면, 
>> 일반 함수  - 선언과 정의가 정상적으로 함께 존재합니다.  
>> 순수 가상 함수 - 선언만 존재합니다. 정의는 파생 클래스에서 해줄 것으로 기대합니다.  
>> 일반 가상 함수 - 선언과 정의가 존재하되, 재정의될 것을 기대합니다.  
>> 만약, 일반 가상함수를 정의한 클래스  A가 존재한다고 전제합니다.  
>> A의 상속을 받은 파생 클래스 B가 있을 때,  
>> B가 A의 가상함수를 오버라이딩했습니다.  
>> 이 때, A 타입 참조/포인터에 B의 인스턴스를 복사해서 넣었습니다.  
>> 일반 함수 A가 정의되어 있었다면 보통 참조나 포인터에 해당하는 형식으로  
>> 해당 클래스를 해석하기 때문에, 일반 클래스 A에 존재하는 함수를 호출하겠죠.  
>> 하지만, 가상 함수로 정의했다면 실형식인 파생 클래스 B의 메서드를 호출합니다.  
>> 제 아무리 해석형식을 A로 해주었다 해도 말이죠.  
```C++
class A { 
public:
  virtual void printData() {
    cout << "A::printData()" << endl;
  }  // 가상함수
}
class B : public A {
  virtual void printData() {
    cout << "B::printData()" << endl;
}

int main() {
  B a;
  A &b = a;       // A의 포인터로 선언해도 됨.
  
  b.printData();
  return 0;
}
```
>> 위 코드의 기대 결과는  
>> B::printData()  일 것입니다.  
>> 접근 형식을 기준으로 생각하면 A의 함수가 호출되어야 맞겠습니다만,  
>> 가상 함수를 이용하면 실 형식을 기준으로 함수를 호출하게 되니까 말이죠.  

>> 만약 A의 함수가 가상 함수가 아니었다면,    
>> 참조 형식에 따라서 호출되었을 것입니다. 즉,    
>> A의 참조이므로 A의 함수가 호출되었겠죠.  

>> 즉, 가상함수는 실 형식을 따르고, 일반 함수는 참조 형식을 따라서 함수를 호출합니다.  

## 일반 가상함수, 순수 가상함수
  1. 일반 가상함수
    - 일반 가상함수는 몸체가 있는 가상함수입니다. 위에 적은 대로,  
    - 가상함수를 오버라이딩한 클래스가 실 형식일 경우  
    - 실 형식의 가상함수가 호출됩니다.  
  2. 순수 가상함수
    - 몸통이 비어있는 가상함수입니다. 미래에 재정의할 것을  
    - 완벽하게 요망하는 함수죠. 
>> 만약 일반 가상함수로 실행되어 있다면,  일반 클래스에 누군가가  
>> 그 가상함수의 몸통부분을 정의해놓은 것이겠죠.  
>> 그렇다면, 파생 클래스 몸통을 정의할 때 일반 클래스의  
>> 몸통 또한 불러줘도 괜찮을 겁니다. 
>> ex) 클래스 A의 파생 클래스 B가 존재할 때,  
>> 클래스 A에 가상메서드 getData가 존재한다.
>> 근데, B에서 받는 Data의 범주를 제한하고 싶어서 함수를 재정의했다.  
>> 0~10사이의 값을 받기로 했다.  
>> 그러면 상위 클래스의 가상함수를 몸통부분에서 "호출"해주고,  
>> 유효값 검사만 해서 잘라주면 되지 않을까?  

>> 이런 느낌인거죠. 그 상위 가상함수를 "언제", "어떻게"  
>> 호출할 지는 프로그래머의 자유인 거고요.  

## final
