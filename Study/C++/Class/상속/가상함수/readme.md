# 가상함수
>> virtual 키워드를 통해 정의합니다.  
>> 메서드 선언 시에  virtual, const, static 등의  키워드를 붙일 수 있는데,  
>> 앞에 붙여주면 됩니다.  
>> 가상함수의 개념은 무엇일까요? 우선, 미래에 재정의될 것을 기대하는  
>> 함수라고 보면 됩니다. 즉, 오버라이딩해줄 것이 기대되는 함수입니다.  
>> 자식 클래스에서 반드시 "오버라이딩" 해 줄 것이 기대된다는 것은,  
>> 미래의 코드 작성자에게 코드를 맡기는 것과도 같죠.  
>> 함수의 종류를 구분하자면, 
>> 일반 함수  - 선언과 정의가 정상적으로 함께 존재합니다.  
>> 순수 가상 함수 - 선언만 존재합니다. 정의는 파생 클래스에서 해줄 것으로 기대합니다.  
>> 일반 가상 함수 - 선언과 정의가 존재하되, 재정의될 것을 기대합니다.  
>> 만약, 일반 가상함수를 정의한 클래스  A가 존재한다고 전제합니다.  
>> A의 상속을 받은 파생 클래스 B가 있을 때,  
>> B가 A의 가상함수를 오버라이딩했습니다.  
>> 이 때, A 타입 참조/포인터에 B의 인스턴스를 복사해서 넣었습니다.  
>> 일반 함수 A가 정의되어 있었다면 보통 참조나 포인터에 해당하는 형식으로  
>> 해당 클래스를 해석하기 때문에, 일반 클래스 A에 존재하는 함수를 호출하겠죠.  
>> 하지만, 가상 함수로 정의했다면 실형식인 파생 클래스 B의 메서드를 호출합니다.  
>> 제 아무리 해석형식을 A로 해주었다 해도 말이죠.  
```C++
class A { 
public:
  virtual void printData() {
    cout << "A::printData()" << endl;
  }  // 가상함수
}
class B : public A {
  virtual void printData() {
    cout << "B::printData()" << endl;
}

int main() {
  B a;
  A &b = a;       // A의 포인터로 선언해도 됨.
  
  b.printData();
  return 0;
}
```
>> 위 코드의 기대 결과는  
>> B::printData()  일 것입니다.  
>> 접근 형식을 기준으로 생각하면 A의 함수가 호출되어야 맞겠습니다만,  
>> 가상 함수를 이용하면 실 형식을 기준으로 함수를 호출하게 되니까 말이죠.  
