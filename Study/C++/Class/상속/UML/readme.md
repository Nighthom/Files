# UML

>> [GitMind](https://gitmind.com/app/my)  
>> 위 사이트는 UML 다이어그램이나 플로우차트 등 여러가지 유용한    
>> 템플릿들을 이용할 수 있는 웹 페이지입니다.    

>> UML 다이어그램을 이용하면, 객체지향 프로그래밍에 쓰이는    
>> 클래스, 인스턴스, 각 메서드들 사이의 관계를 미리    
>> 설계하기가 용이합니다.    
>> 이러한 UML을 이용해서 미리 설계를 하고 어떻게 상속을 할까?     
>> 어떻게 인스턴스들을 구성할까?    
>> 어떻게 메서드들을 구현하고, 어떻게 하나의 Class로 엮을까?    
>> 이에 대한 설계를 미리 하는겁니다.    


## 클래스 다이어그램
>> 클래스는 사각형 내부의 최상단 칸에는 클래스의 이름,    
>> 중간 칸에는 클래스의 프로퍼티들,    
>> 마지막 칸에는 클래스의 메서드들을 넣어서 그립니다.    
>> 프로퍼티의 자료형과 메서드의 반환 자료형 또한 넣어줍니다.    
![](https://github.com/Nighthom/Files/blob/main/Study/C%2B%2B/Class/%EC%83%81%EC%86%8D/UML/%EC%82%AC%EC%A7%84%ED%8C%8C%EC%9D%BC/%ED%81%B4%EB%9E%98%EC%8A%A4.png)  

## 클래스 스테리오 타입
>> 스테리오 타입이라는 것은 UML에서 제공하는 기본적인 요소 이외에    
>> 제공되는 다른 요소를 의미합니다.    
![](https://github.com/Nighthom/Files/blob/main/Study/C%2B%2B/Class/%EC%83%81%EC%86%8D/UML/%EC%82%AC%EC%A7%84%ED%8C%8C%EC%9D%BC/%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B8%EB%9F%AC%EB%A9%A7.png)  
>> 길러멧( << >> ) 이라는 쌍꺾쇄 모양의 문자를 쓰는데, 엄밀히 말해서 쌍꺾쇄와 다른 기호입니다.  
>> interface는 C++기준으로는 순수 가상 클래스? 추상 클래스? 정도로 이해하시면 좋습니다.  

## 클래스 다이어그램 : 관계
![](https://github.com/Nighthom/Files/blob/main/Study/C%2B%2B/Class/%EC%83%81%EC%86%8D/UML/%EC%82%AC%EC%A7%84%ED%8C%8C%EC%9D%BC/%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8_%ED%99%94%EC%82%B4%ED%91%9C%EB%93%A4.png)  
>> 위의 사진이 관계들을 나타내는 화살표들입니다. 차례로 설명하겠습니다.  
  ### 1. 일반화 관계(Genaralization)

![](https://github.com/Nighthom/Files/blob/main/Study/C%2B%2B/Class/%EC%83%81%EC%86%8D/UML/%EC%82%AC%EC%A7%84%ED%8C%8C%EC%9D%BC/%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D.png)    

>> 여러가지 객체들이 가지고 있는 공통적인 특성을 모아 일반화하는 관계입니다.  
>> 일반화 관계는 일반적인 객체지향 언어에서는 상속으로 구현됩니다.  
>> University Class를 상속받은 Professor과 Student의 관계입니다.  
  ### 2. 실체화 관계(Realization)
>> 추상 클래스 A를 상속받은 파생 클래스 B가 있을 때,  
>> 이 A와 B와의 관계가 실체화 관계입니다.  
>> implementation이 실질적으로 B에서 이루어지고, A는   
>> B라는 클래스의 틀을 잡아주는 역할을 하는 것이죠.  
>> 일반적으로 interface의 역할을 하는 친구입니다.  
  ### 3. 의존 관계(Dependency)
>> 클래스 다이어그램에서 일반적으로 제일 많이 사용되는 관계입니다.  
>> 어떤 클래스가 다른 클래스를 참조하는 경우, 의존 관계에 있다고 합니다.  
>> 어떤 식으로 참조하는지.. 길러멧을 이용해서 나타내주면 더 좋겠죠.  
  ### 4. 연관 관계(Association), 방향성 있는 연관 관계(Direct Association)
>> 어느 클래스에서 다른 객체의 참조를 가지고 있다면, 그것을  
>> 연관 관계라고 합니다. 즉, 다른 객체로 접근할 수 있다면   
>> 연관 관계입니다.
>> 양방향으로 접근 가능하면 양방향 화살표를 그리거나,  
>> 생략해서 직선으로 그립니다.  
>> 단방향으로 접근 가능하면, 단방향으로 화살표를 그려서  
>> **방향성 있는 연관 관게** 임을 나타내 줍니다.  
>> 만약, 참조가 몇개인지 정해져 있다면 \* 옆에 참조의 갯수를  
>> 기록해줍니다.  

  ### 5. 집합 관계(Aggregation)
>> Aggregation은 연관 관계를 특수화한 것으로,  whole(전체)와  
>> part(부분)으로 나누어 집니다. 어떠한 객체들(part)이 하나의 객체(whole)에 모여 있는 개념인데,  
>> 하나의 객체가 사라진다고 해서(전체가 사라진다고 해서) part에 해당하는 부분들이 사라지지 않습니다.  
>> 집합이냐 아니냐의 차이가 있긴 합니다만,  
>> 소스 코드 상에서는 그 둘의 차이를 분간하기가 거의 힘듭니다.  
>> pointer나 reference를 이용해서 whole이 part의 프로퍼티를 갖는 형식으로 구현됩니다.  
>> 그리는 법은 whole과 part 사이에 선을 긋고, whole쪽에 속이 빈 다이아몬드 하나를 그려줍니다.  
>> part쪽에 화살표는 그려도 되고 안그려도 됩니다.  
  ### 6. 합성 관계(Composition / Composite Aggregation)
>> 합성 관계 또한 집합 관계처럼 whole과 part의 관계를 갖습니다.  
>> 하지만 이 둘의 연관관계가 더 강해요.  
>> whole이 사라져도 part가 사라지지 않던 Aggregation과는 달리,  
>> whole이 사라지면 part가 같이 사라집니다.  
>> 소스코드 상에서는 whole이 part의 참조나 포인터가 아닌  
>> 실제 인스턴스를 갖는 식으로 구현됩니다.  
  
## 시퀀스 다이어그램


