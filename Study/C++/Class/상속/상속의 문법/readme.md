# 상속의 문법 

```C++
class A {
  class A implimentation....
}
class B : public A {
  class B implementation...
}
```
>> 다음과 같은 식으로 작성되었을 떄,  
>> 클래스 B는 클래스 A를 상속(Inheritance)했다고 합니다.  

>> 상속할 때 public 외의 접근 지시자를 정해줄 수도 있는데,  
>> 대부분의 상속은 public으로 정의합니다.  
>> A는 B의 부모 클래스 / 기본 클래스, B는 A의 자식 / 파생 클래스입니다.  
>> B의 생성자가 호출되면 A의 생성자도 같이 호출됩니다. (즉, B는 A+B 꼴이 됩니다.)  
>> B가 소멸할 때도 A의 소멸자가 같이 호출됩니다.  
>> B는 A의 멤버들에 접근 가능합니다. private 멤버는 접근할 수 없습니다.  
>> B의 인스턴스 b가 존재한다면, 사용자 코드에서 b 인스턴스는  
>> class A의 메서드에 접근 가능합니다. private 메서드는 접근 불가능합니다.  
>> 기본적으로 A는 B보다 선행되어서 작성되는 코드고,  
>> B는 A보다 나중에 작성되는 코드입니다. 즉, A 클래스는  
>> B 클래스를 위해서 Interface를 잘 정의해 줄 필요가 있어요.  


>> B클래스에서 A 클래스의 메서드인 getData()에 접근한다고 칩시다.  
>> 그러면 
```C++
A::getData();
getData();
```
>> 이런식으로 접근할 수 있습니다.  


## Override
>> 파생 클래스 B에서는 A의 메서드 setData를 Override(재정의) 할 수 있습니다.  
>> 메서드 재정의를 할 경우, B 안에서는 A의 메서드라고 명시하지 않는 이상  
>> B의 메서드 setData를 호출하게 됩니다.
```C++
class A {
  int nData;
public:
  void setData(int nParam) {
    nData = nParam;
  }
}

class B : public A {
public:
  void setData(int nParam) {        // Override
    if(nParam > 10) {
      // setData(10) 과 같이 호출하면 오버라이드된 setData를 무한히 재귀호출함.  주의!
      A::setData(10);
      reuturn;
    }
    if(nParam < 0) {
      A::setData(0)
      return;
    }
}
```
>> 위 상황은 B를 제작한 후기 제작자가 A 클래스의 setData에 없는    
>> 새로운 기능을 삽입한 모습입니다. 기존 코드에는 0 ~ 10까지의 범주에 맞는     
>> 값을 보정하는 기능이 없었지만, 이러한 기능이 필요하다고 느껴    
>> 하위 클래스를 정의해서 오버라이드해 준 것입니다.

## 어떠한 참조의 실 형식과 접근형식
```C++ 
CTestEx a;
CTest &b = a;         // a를 가리키는 참조 b. 문법 에러 없음.
```
>> a의 참조 b가 CTest 클래스를 접근 형식으로 받았습니다.  
>> 만약 다음과 같은 상황이면 어떨까요?  
```C++
b.setData(13);
```
>> 이러면 CTestEx의 인스턴스 a는 CTestEx가 오버라이드한 setData()를 호출하지 않습니다.    
>> 이유는, CTest형식으로 접근했기 떄문이죠.  
>> 따라서, 일반 클래스 CTest의 setData()를 호출하게 됩니다.  
>> 그러면 a.m_nData는 13으로 set되겠네요.  

## 메서드별 접근형식
  1. 일반 메서드 --> 만약 위와 같은 참조가 발생했을 때, **접근 형식**을 따라가게 된다.
  2. 가상(Virtual) 메서드 --> 만약 위와 같은 참조가 발생했을 때, **실제 형식**을 따라가게 된다.
  3. 정적(Static) 메서드
>> 가상함수에서는 CTestEx 의 setData()를 호출할 수 있겠네요!  
## 파생 클래스와 일반 클래스 생성자 사이의 순서
>> 일반 클래스 A와 파생 클래스 B가 있을 때,  
>> B의 인스턴스 b를 생성합니다.  
>> 그러면 B의 생성자가 호출됩니다.  
>> 그 다음 A의 생성자가 호출됩니다.  
>> 하지만, 중요한 사실이 하나 있습니다.   
>> B의 본문이 실행되기 이전에 A의 생성자를 호춣한다는 거죠.  
>> 즉, 함수로 표기하면 이렇습니다.  
```C++
B() {
  A()
  B 본문
}
```
>> 따라서, B의 생성자가 먼저 호출되긴 하지만 A의 생성자가 먼저   
>> 실행됩니다.  즉, 호출 순서와 실행순서가 반대입니다.  
>> 먼저 호출된 생성자가 가장 나중에 실행됩니다.  

>> 소멸자는 이와 반대로, 실행이 되고 상위 클래스의 소멸자를   
>> 호출합니다. 즉, 실행 순서와 호출 순서가 동일합니다.  


## 생성자의 대명제!  
>> 생성자는 항상 자기 자신을 **초기화** 하는 일만  
>> 부여해야 합니다.  
>> 생성자에 다른 기능을 집어넣으면 **예상하지 못한 결과**  
>> 가 나올 수 있다는 것을 기억하셔야 해요.  
>> **부모 클래스** 멤버를 초기화하는 행위는 해서도 안됩니다.  
>> 이를 막으려면, 애초에 클래스의 Data를 설계할 떄  
>> **private**로 설계하는게 좋습니다.  

## 생성자 선택
>> 하위 클래스 B는 상속받은 A의 생성자 중에서  
>> 어떤 생성자가 호출될 것인지 선택할 수 있습니다.  
```C++
class A {
  int m_nData;
public:
  A() { m_nData = 10; }           // 디폴트 생성자
  explicit A(int nParam) {        // 변환 생성자 1
    m_nData = nParam;
  }
  explict A (double dParam) { }   // 변환 생성자 2
  A(const A& rhs) {               // 복사 생성자
    m_nData = rhs.m_nData;
  }
}
class B : public A {
public:
  B() { }
  B(int nParam) : A(nParam) { }     // A의 생성자 중 int형 인자를 받는 생성자를 선택했다.
  B(double dParam) : A() { }        // A의 생성자 중 default 생성자를 선택했다.
}
```
>> 위와 같은 소스코드는 생성자 선택에 관련된 문법입니다.  
>> 하위 클래스 B에서 생성자 호출을 해주는데, 어떤 생성자를  
>> 어떤 파라미터로 받아서 생성해 줄 지 상위 클래스 A는 알지 못합니다.  
>> 따라서 이에 대한 정보를 하위 클래스에서 주입해 줄 수 있습니다.  

## 생성자 상속(C++ 11)
```C++
class B : public A {
public:
  using A::A;
}
```
>> 위와 같이 표기하면 한번에 클래스 A의 생성자들을  
>> B에서도 상속받을 수 있어요.  즉, 아래와 똑같은 코드인거죠.  
```C++
class B : public A {
public:
  B() : A() { } 
  B(int nParam) : A(nParam) { }
  B(double dParam) : A(dParam) { }
}
```
>> 매우 편리하죠? 부모 클래스의 생성자가 몹시 많을 떄  
>> 이런 식으로 해주면 각각 따로따로 정의해 줄 필요가 없어 편하답니다.  

 
