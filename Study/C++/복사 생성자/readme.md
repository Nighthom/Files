# 복사 생성자와 임시 객체

## Deep Copy, Shallow Copy
>> **Shallow Copy**는 해당 객체에 참조하는 방식을   
>> 늘리는 형식의 Copy입니다.  
>> 해당 객체를 참조할 수 있는 포인터를 여러개로 늘린다던가,  
>> 참조를 여러개로 늘린다던가 해서 구현할 수 있죠.  
>> **Deep Copy**는 해당 객체를 진짜 Copy해서 여러군데  
>> 가져다 붙이는 것을 의미합니다.  
>> 복사 생성자로 생성하는게 Deep Copy에 해당됩니다.  

>> Shallow Copy의 위험성중 하나는,  
>> 두 개의 참조 / 포인터로 하나의 객체를 가리킬 때  
>> 그 중 하나의 참조/포인터에서 그 값을 delete해버린다면?  
>> 하나는 쓰레기 값을 가진 포인터를 갖게 되겠죠?  
>> 이러한 포인터를 Dangling Pointer라고 합니다.
## 복사 생성자
```C++
int a = 10;   // 절차지향 언어 스타일 변수 초기화   ... 1번(C 스타일 단순대입)
int a(10);     // 객체지향 언어(C++) 스타일 객체 생성(int형 객체 a의 생성자에 10을 넣는다.) .... 2번
int b(a);       // int형 객체 a를 복사해서 b에 붙여넣는다.    ...3번
```

>> 1번 코드는 변수 초기화입니다.    
>> 2번 코드는 int형 객체 a의 생성자에 0을 넣습니다.   
>> 3번 코드는 int형 객체 a를 b에 복사해서,   
>> "기본 복사 생성자" 가 불린 것이죠.    
>> 완벽하게 똑같은 객체를 만들어 줍니다.  

>> C++에서는 디폴트 복사 생성자라는 것이 있습니다.  
>> 기본적으로 객체를 Shallow Copy 해주는 것이죠.  

>> 만약 객체를 Shallow Copy 해주고 싶다면,  
>> 디폴트 복사 생성자를 따로 정의해야겠죠.  
>> Deep Copy를 이용해서 만들 수 있도록 해야 합니다.  

```C++
class CMyData {
public:
  CMyData(const CMyData &rhs)           //  복사 생성자는 매개변수로 복사할 인스턴스의 
                                        //  "상수" 참조형을 받는다. 주로 rhs로 식별자를 많이 씀.    
  // : m_nData(rhs.m_nData) 와 동치
  {
    this->m_nData = rhs.m_nData;
  }
private:
  int* m_nData;
}
```
>> 이런 식으로 정의하면, deep copy를 수행합니다.  
>> (단순 instance 참조 / 포인터 복사가 아닌,  
>> 멤버의 값을 직접적으로 복사해서 포인터를 따로 지정해준다!)  
>> shallow copy는 단순 포인터 대입 연산으로 수행되기 때문에,  
>> 이것이 필요한 상황이 아니라면 **deep copy** 로 복사 생성자를  
>> 꼭 재정의하시길 바랍니다!  

## shallow copy를 썼을 떄 생길 수 있는 문제점
>> 예를 들어, 포인터를 프로퍼티로 갖고있고,  
>> 그 포인터에 new로 새로운 인스턴스를 a에 할당해 줬다고 칩시다.   
>> 이를 shallow copy해서 b라는 포인터에 지정해줍시다.   
>> 그러면, 소멸자에 delte를 집어넣으면  
>> 호출되는 시점에서 a나 b에 있던 인스턴스는 죽겠죠?   
>> 근데 나머지 하나는 유효하지 않은 값을 가진 포인터를 여전히 가리키고 있습니다.  
>> 소멸자를 한번 더 호출하겠죠. 그러면 유효하지 않은 포인터에  
>> 액세스 하게 되어 프로그램이 죽게 됩니다.  

## 단순 대입 연산자 '='과 shallow copy
>> 단순 대입 연산자 =은 l-value에 r-value를  
>> Overwrite하는 연산입니다.   
>> 따라서, 객체를 단순 대입하면 또 deep copy와  
>> shallow copy 문제가 발생하게 됩니다.  
>> 만약에 deep copy가 필요한 객체에 단순 대입 연산자를  
>> 오버로딩하지 않았다면, 복사 생성자로 선언하면 문제가 없겠지만,  
>> 단순 대입 연산을 수행하면 복사 생성자 쓸때처럼 또 죽겠죠?  

>> 이럴 때 **연산자 오버로딩** 을 이용해서 '=' 연산자를  
>> 재정의해주어야 합니다.  
```C++
CMyData& operator=(const CMyData &rhs) {
  *m_nData = *this.m_nData;         // 내용을 deep copy해준다.
  
  return *this;                    // 객체 자신에 대한 참조를 반환
}
```
>> 위와 같은 문법으로 **연산자** 를 재정의 해 줄 수 있습니다.  
```C
a = b;
a.operater=(b):
```
>> 위 두 코드는 **똑같은 함수** 를 호출합니다.  
>> 하지만 a=b가 더 편하겠죠?  
>> **연산자 오버로딩**의 더 정확한 내용은 연산자 오버로딩 파트에서 다룹니다.  
