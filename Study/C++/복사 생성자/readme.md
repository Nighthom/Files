# 복사 생성자와 임시 객체

## Deep Copy, Shallow Copy
>> **Shallow Copy**는 해당 객체에 참조하는 방식을   
>> 늘리는 형식의 Copy입니다.  
>> 해당 객체를 참조할 수 있는 포인터를 여러개로 늘린다던가,  
>> 참조를 여러개로 늘린다던가 해서 구현할 수 있죠.  
>> **Deep Copy**는 해당 객체를 진짜 Copy해서 여러군데  
>> 가져다 붙이는 것을 의미합니다.  
>> 복사 생성자로 생성하는게 Deep Copy에 해당됩니다.  

>> Shallow Copy의 위험성중 하나는,  
>> 두 개의 참조 / 포인터로 하나의 객체를 가리킬 때  
>> 그 중 하나의 참조/포인터에서 그 값을 delete해버린다면?  
>> 하나는 쓰레기 값을 가진 포인터를 갖게 되겠죠?  
>> 이러한 포인터를 Dangling Pointer라고 합니다.
## 복사 생성자
```C++
int a = 10;   // 절차지향 언어 스타일 변수 초기화   ... 1번(C 스타일 단순대입)
int a(10);     // 객체지향 언어(C++) 스타일 객체 생성(int형 객체 a의 생성자에 10을 넣는다.) .... 2번
int b(a);       // int형 객체 a를 복사해서 b에 붙여넣는다.    ...3번
```

>> 1번 코드는 변수 초기화입니다.    
>> 2번 코드는 int형 객체 a의 생성자에 0을 넣습니다.   
>> 3번 코드는 int형 객체 a를 b에 복사해서,   
>> "기본 복사 생성자" 가 불린 것이죠.    
>> 완벽하게 똑같은 객체를 만들어 줍니다.  

>> C++에서는 디폴트 복사 생성자라는 것이 있습니다.  
>> 기본적으로 객체를 Shallow Copy 해주는 것이죠.  

>> 만약 객체를 Shallow Copy 해주고 싶다면,  
>> 디폴트 복사 생성자를 따로 정의해야겠죠.  
>> Deep Copy를 이용해서 만들 수 있도록 해야 합니다.  

```C++
class CMyData {
public:
  CMyData(const CMyData &rhs)           //  복사 생성자는 매개변수로 복사할 인스턴스의 
                                        //  "상수" 참조형을 받는다. 주로 rhs로 식별자를 많이 씀.    
  // : m_nData(rhs.m_nData) 와 동치
  {
    this.m_nData = rhs.m_nData;
  }
private:
  int m_nData;
}
```
>> 이런 식으로 정의하면, deep copy를 수행합니다.  
>> (단순 instance 참조 / 포인터 복사가 아닌,  
>> 멤버의 값을 직접적으로 복사해서 포인터를 따로 지정해준다!)  
>> shallow copy는 단순 포인터 대입 연산으로 수행되기 때문에,  
>> 이것이 필요한 상황이 아니라면 **deep copy** 로 복사 생성자를  
>> 꼭 재정의하시길 바랍니다!  

