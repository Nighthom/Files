# 객체지향 프로그래밍

>> C++는 C언어를 확장해서 "객체지향"의 개념을 넣는데서 시작한 언어입니다.  
>> 초기 C++는 Classes with C 라는 이름으로 나왔었죠.  
>> 즉, C++는 객체지향 패러다임을 C에 추가한 언어.. 에 가깝습니다.  

>> 그렇다면, 객체지향 패러다임이라는 것은 무엇일까요?

## C와의 차이점
>> C에도 **객체**라는 개념은 존재합니다.  
>> 어떠한 변수, 함수, 구조체.. 등등 어떠한 **유의미한** Data를 담는  
>> 공간 그 자체가 바로 객체입니다.  
>> 하지만, C언어에서는 이러한 객체들이 어떠한 **동작** 을 하게 만드려면,  
>> main함수에서 순차적으로 함수라는 Subrutine들을 실행시킴으로써 동작시킵니다.  
>> 함수의 인자로 객체들을 전달하고, 이러한 객체들을 코드가  
>> 이용해서 직접 객체들을 관리하죠.  

>> 객체지향 패러다임은 이러한 객체에 대한 개념을 **확장**시킵니다.     
>> 객체가 단순히 피동적으로 어떠한 코드나 함수에 의해서 상태가 변화하거나,    
>> 출력되거나, 행동을 취하기만 하는 수동적인 객체가 아닌,    
>> **객체 그 자신**이 능동적으로 행동을 취하거나,     
>> 어떠한 상위 객체의 개념에 **포함**될 수도 있습니다.  
 
>> C의 객체는 자료형을 갖고, 자료형이 구조체, 공용체 등 여러 형태로     
>> 객체를 해석하는 방식이라면,    
>> 객체지향 언어 또한 자료형이 있지만, 구조체 대신 객체지향 언어는   
>> **Class** 라는 것을 지원합니다. Class 형태로 선언된 객체들은   
>> 해당 Class의 **Instance**라고 합니다.  


# 캡슐화, 상속, 다형성, 추상화
>> 객체 지향 4요소라 불리는 요소입니다.  

>> 캡슐화는 어떠한 클래스에 있는 속성(프로퍼티)의 요소들을 은닉하는  
>> 행위를 뜻합니다. private같은 걸로 은닉할 수 있겠네요. 그리고, 그 함수들이  
>> 수행할 동작에 관련된 것들은 public으로 공개하는 것이죠.  
>> 이렇게 했을 때 장점은, 객체 제어를 제한적인 방법으로만 수행 가능하다는 것이죠.  
>> 그렇다면, 사용자에게 이런 객체 제어에 대한 방법을 전해줄 필요가 없습니다.  

>> 상속은 어떠한 부모 클래스가 하나 이상의 자식 클래스를 가질 수 있다는 것이죠.  
>> 부모 클래스 또한 또다른 부모 클래스를 가질 수 있습니다.  
>> 자식 클래스는 상속받은 부모 클래스의 프로퍼티, 메소드 등을 이용할 수 있어요.

>> 다형성은 함수 Overiding과 Overload를 의미합니다.  
>> 하나의 함수가 여러가지 형태를 지닐 수 있도록 프로그래밍할 수 있다! 는 의미죠.   
>> Overriding은 부모 클래스의 메서드와 같은 이름의 메서드를 자식 클래스에서 재정의하는 것입니다.   
>> Overload는 같은 이름의 함수라고 하더라도 인자로 다른 값을 전달하면,  
>> 서로 다른 함수처럼 호출할 수 있습니다.  

>> 같은 이름을 가진 함수더라도, 어느 클래스에 속한 객체냐에 따라서   
>> 다르게 호출할 수 있으며, 인자를 어떻게 전달하냐에 따라서 다른 동작을 지원할 수도 있는거죠.    

>> 추상화는 어떠한 객체를 바라볼 때, 그 객체를 동작시키는 어떠한 방식을 몰라도  
>> 사용자가 동작시킬 수 있도록 해주는 겁니다. 추상은 Interface 영역이고,  
>> 구현은 Implement 영역이죠.  
>> Class에 정의된 메서드를 통해서 우리는 그 객체를 동작시킬 수 있습니다.  
>> 그 객체에 어떤 매개변수를 전달해야 할 지 모르고, 어떤방식으로 객체가 생성되고  
>> 저장되는지조차 알지 못한다고 해도, 알아서 메서드를 제작한 사람이   
>> 잘 정의시켜 놓았을 겁니다.  
>> 우리가 알아야 할 건 Interface의 생김새와 그 동작이 어떤식으로 이루어지는가죠.  
