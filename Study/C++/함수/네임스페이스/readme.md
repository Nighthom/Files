# 네임스페이스

```C++
namespace SJ {
  int a;
  int b;
  
  void printscreen() {
    std::cout << "Hello, Screen!\n" << std::endl
  }
}
```
>> 네임스페이스는 위와 같이 선언합니다.  
>> 네임스페이스 내부의 전역변수 및 함수들은  

```C++
SJ::a = 1;
SJ::B = SJ::A+1;

SJ::printscreen();
```
>> 이런식으로 정의하거나, 호출할 수 있습니다.  

>> 클래스도 이 네임스페이스 안에 넣을 수 있습니다.  
>> 즉, 네임스페이스는 특정 스코프 안에 있는 멤버들에 대해서  
>> "소속"같은 개념을 부여하는 문법입니다.  
>> :: 연산자는 범위 지정 연산자라고 합니다.
>> 정말 중요한 내용 중 하나로,  
>> 위와 같은 형식으로 선언하면 컴파일러가 컴파일할 떄,  
>> a를 식별자에 붙이는게 아닌,  
>> SJ::a 이런식으로 식별자를 붙여줍니다.  


# Using Keyword
```C++
using namespace SJ;
using namespace std;
```
>> 위와 같이 using 키워드를 사용해서 네임스페이스를 만들면,     
>> 네임스페이스를 "생략" 하고 입력해도 알아서 범위 지정 연산자가 적용됩니다.    
>> 식별자 검사에서 문제가 발생할 수 있으니, 주의하셔야 합니다.  

# 네임스페이스의 중첩
>> 네임스페이스는 중첩해서 적용할 수 있습니다.  
>> 예를 들어볼까요?  
>> 천안시 << 동남구 << 목천읍 << 신계리 :: numberofPeople();
>> 위와 같은 구조라면, 천안시에 소속된 동남구에 소속된 목천읍에 소속된 신계리..  
>> 라는 뜻이겠죠. numberofPeople은 해당 지역의 사람 수를 계산하는 함수라고 칩시다.  
>> 아무튼, 이런 식의 중첩이 가능합니다.  

# 네임스페이스가 없는 전역 변수 / 함수
>> 네임스페이스가 없는 함수나 변수는  
>> 묵시적으로 아무것도 입력하지 않아도  
```C++
int Add(int a, int b);
Add(2, 3);         // 이 구문을
::Add(2, 3);       // 컴파일러가 이렇게 해석합니다.
```
>> 아무것도 없는 네임스페이스처럼 해석합니다.  
>> 만약 using 키워드를 사용중이라면,  헷갈리겠죠?  
>> 명시적으로 이렇게 ::를 붙여주면, 아 저 함수는  
>> 네임스페이스가 없구나! 하고 깨닫기 편하겠죠.  
