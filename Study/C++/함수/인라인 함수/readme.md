# 인라인 함수  

>> 인라인 함수는 C/C++ 컴파일러에서 지원하는 "최적화" 기법입니다.        
>> 함수를 호출할 경우, 함수의 파라미터를 스택에 옮기거나, 레지스터에 쓰는 등        
>> 오버헤드가 발생합니다. 또한, call을 이용해 함수로 점프하는 행위도 오버헤드죠.        
>> 스택프레임을 씌워주고 다시 벗기면서 원래 구문으로 돌아오는 것 또한 오버헤드입니다.      
>> 인라인 함수는 이러한 함수를 그냥 함수가 아닌 코드처럼 함수가 호출되는 부분에      
>> 붙여넣어 주고, 이를 함수 호출과 동일한 논리로 동작하게 만들어 줍니다.      

>> 함수가 일정 규모 이하라면, 이러한 인라인 함수는 함수 호출의 오버헤드를        
>> 없애주는 아주 훌륭한 최적화 기법입니다.       
>> 하지만, 함수의 규모가 커지면 호출할 때마다 그 구문에 함수 전문을 붙여넣어      
>> 주어야 하므로 메모리를 장난아니게 잡아먹겠죠. 이는 효율적이지 못합니다.      
>> 따라서 컴파일러는 규모가 작은 함수를 대상으로 인라인 함수를 알아서 적용시켜 줍니다.      

```C++
inline int add(int a, int b);
```
>> 이런식으로 인라인 함수로 컴파일하라! 라는 예약어로 컴파일러에게    
>> 지시정도는 해 줄 수 있지만, 이 구문은 컴파일러가 판단하기에    
>> 부적합하다면 무시됩니다.  
>> 물론 옵션을 비활성화해서 인라인 함수를 안 만들 수도 있습니다.  
>> 매크로 함수랑 비교하자면,  매크로 함수는 문법적으로 함수가 아니기 때문에  
>> 문법적인 에러가 생기면 바로잡기 힘들죠.  
>> 하지만 인라인 함수는 함수로 인식하고 컴파일러가 번역하기 때문에   
>> 실수를 획기적으로 줄여줄 수 있습니다.   

>> 최적화에 대한 이론을 덧붙이자면,     
>> 변수 또한 필요없다 싶으면 최적화해서 사용하지 않고,     
>> 실제 어떠한 동작도 하지 않는 함수라면 알아서 그냥 호출을 안해버립니다.     
>> 이런 최적화할 변수에 대한 힌트는 변수가 적을수록 좋습니다.     
>> 상수를 잘 써야 해요.   


>> 대응되는 것으로는 매크로 함수가 있습니다.  
[매크로 함수](https://github.com/Nighthom/Files/tree/main/Study/C/lesson/%EC%A0%84%EC%B2%98%EB%A6%AC%EA%B8%B0/%EB%A7%A4%ED%81%AC%EB%A1%9C%20%ED%95%A8%EC%88%98)  
