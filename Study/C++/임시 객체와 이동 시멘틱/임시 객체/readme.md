# 임시 객체

## 이름이 없는 임시 객체  
>> 이름이 없는 임시 객체란, 말그대로 식별자가 붙지 않은  
>> 객체입니다. 함수를 호출하고 반환할 때마다 항상 생성되는 임시  
>> 객체가 있어요. 클래스가 되었건, 기본 자료형이 되었건, 어떠한 객체를  
>> 반환하는 함수는 반환시에 임시 객체를 활용합니다.  
>> 정수형 데이터의 경우,  
>> x86 아키텍쳐에서는 eax 레지스터에, x64 아키텍쳐에서는  
>> rax 레지스터에 임시 객체를 저장하고, 함수 호출한 구문에 반환값을   
>> 전달해 주죠.  
>> 함수 연산 제외하고도 레지스터를 활용하는 연산은 많죠?  
>> 예를 들어 레지스터에서 add 연산을 수행한다고 치면,  
>> eax가 되었든 ecx가 되었든 값을 옮기고,  
>> 그 옮긴 값을 대상으로 접근해서 add연산을 수행해요.  
>> 이는 cpu가 destination과 operator을 받을 때,  
>> 둘 다 메모리에 있는 값이면 연산을 못해서 그래요.  
>> 그래서, 레지스터로 옮겨서 연산을 수행하고  
>> 다시 그 값을 메모리로 저장합니다.  
```C++
  int a = 1 + 3;
```
>> 여기 위에서 int형 인스턴스는 몇개일까요?  
>> 4개가 존재합니다.  
>> int형 인스턴스 a, int형 상수 1, 3,   
>> 임시 객체가 저장될 인스턴스 하나.  
>> 임시 객체는(중간 값은) **R-Value** 형태로 저장됩니다.   
>> 즉, Location으로 쓸 수 없어요.     
>> 그리고, 임시 객체의 생명 주기(Life Cycle)는  
>> 다음 연산이 수행된 다음까지에요. 즉, 1+3 결과로 나온 R-Value  
>> 4는 a에 대한 대입연산이 수행될 때 까지 생존하고,  
>> 대입 이후에는 사라지게 되는 것이죠.  

>> CPU에서 이런식으로 처리를 하기 떄문에,  설계 당시에 어떤  
>> 인스턴스를 얼마나 쓰고, 메모리를 얼마나 쓰고 이런걸 계산한 것이  
>> 의미가 없어질 수도 있어요! 기본형식이야 뭐 아무리 많이 먹어봐야  
>> 8바이트, 혹은 16바이트 정도 먹겠죠.  
>> Class 형식을 연산에 이용했다고 칠까요?  

```C++
CTest a, b, c;
c = a + b;                 
```
>> 이러면 CTest 객체는 3개가 눈에 보이죠?  
>> 하지만 이름이 없는 임시 객체 하나가 생성되어서  
>> 연산의 side effect를 위해 존재하게 됩니다.  
>> 그러면 생성자와 소멸자가 원래 예측했던 것보다  
>> 한번이 더 호출되겠네요.  

>> 또, Class 형식을 반환 형식으로 전달했다고 가정해볼까요?   
>> 그러면 임시 객체를 생성할 때 생성자를 호출하고,   
>> 다시 반환되고 값을 넘겨준 뒤, 구문을 벗어나면 rax메모리에서   
>> 해제되면서 소멸자를 호출하겠죠?   
>> 이런 것도 임시 객체로써 존재하겠죠.  

>> 기본 자료형은 사실 별 영향이 없는데,   
>> Class의 경우는 다르죠. Class 인스턴스는 얼마나 큰지도 예측이  
>> 불가능하고, 이러한 임시 객체가 생성되고 소멸되는 오버헤드도 장난 아니겠죠..  
>> 이러한 임시 객체가 심각한 성능 저하를 불러옵니다.  
>> 예를 들어서, List 클래스가 있다고 칩시다.  
>> a 리스트와 b 리스트를 더해서 c 리스트에 더한다고 쳐요.  
>> 근데 a리스트 레코드가 100만개, b리스트 레코드가 100만개면 어떻게 될까요?  
>> 임시 객체 크기가 레코드 200만개가 되겠죠.    
>> 그리고 c 리스트에 복사하면서 또 200만개가 생기겠죠? 임시객체 소멸 전에 말이죠.    
>> 그러면 순식간에 메모리 안에는 레코드 600만개가 생기겠네요.    
>> 임시객체만 200만개 레코드가 있고요.    
>> 메모리를 심각하게 많이 잡아먹겠죠?  


## r-value 참조와 임시 객체(C++11부터 지원)
>> 임시 객체가 생성되는데, 이 임시 객체는 대입연산으로 복사해서 저장할 수 있습니다.  
>> 연산의 중간 결과는 R-Value에요. L-Value처럼 쓰일 수 없겠죠.  
>> 따라서, 이 연산의 중간 결과는 다음 연산 수행 직후 사멸합니다.  
>> 만약에 대입연산을 수행하는데, 이처럼 중간 값을 복사해서 대입하고,  
>> 삭제하는 과정이 필요할까요? 그대로 그 임시 결과값을 가져오면 되는데?  
>> 이러한 중간 연산 과정을 없애기 위한 것이   
>> r-value 참조라는 겁니다.
```C++
int a, b, c;
a = 10, b = 20
c = a + b;
```
>> 에서 중간결과 인스턴스 30은 생성되고 소멸되겠죠.
```C++
int a, b;
int&& c;
c = a + b;
```
>> 하지만 r-value 참조를 이용한다면?  아주 간단하게 해결됩니다.  
>> 그냥 중간결과 값의 참조를 c에다가 저장해버리고,  
>> 임시 객체의 생명주기를 늘려버립니다.  
>> 따라서 임시 객체를 c에 대입하는 오버헤드와,  
>> c에 인스턴스가 복사될떄 발생되는 메모리 오버헤드가 줄겠죠.  
