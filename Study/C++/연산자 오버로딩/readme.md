# 연산자 오버로딩

>>  C++에서는 연산자를 함수로 바꾸어 줄 수 있습니다.  
>>  이를 연산자 함수라고 합니다.  
>>  연산자 함수를 만드는 행위를 연산자 오버로딩이라고 합니다.  
>>  연산자 오버로딩은 기본 자료형에는 할 수 없고,  
>>  class 형식의 객체에만 정의해 줄 수 있어요.  

```C++
// 문법
CTest& operator=(const CTest & rhs){                // 대입 연산자 오버로딩
    this->m_pnData = new int(*rhs.m_pnData);        // 이렇게 하면 복사 생성을 덜 해서 오버헤드가 확 줄어요. 참조를 받아오고, 참조를 반환하면...
    return *this;                                   // 클래스가 매개변수 / 반환이면 참조로 변형해서 넣고, 인자는 반드시 "const"를 붙일 것.  
}
int operaotr+(const CTest& a) {                   // + 연산자 오버로딩
    return m_pnData + a.m_pnData;
}
```
>> 일반 규칙은 다음과 같아요.
   1. \*\*와 같은 새로운 연산자는 정의 불가능
   2. 기본 제공 데이터 형식에 적용할 때 연산자의 의미를 다시 정의 할 수 없습니다.
   3. 오버로드된 연산자 함수는 비정적 클래스 메서드거나 전역 메서드여야 합니다.  
   4. 단항 또는 이항 연산자(-, +, &, \*)로 오버로딩 가능하며,  각 사용을 별도로 오버로딩 할 수 있습니다.  
   5. 오버로딩된 연산자의 첫 번쨰 인자로는 항상 오버로딩된 연산자 자신의 클래스만 올 수 있습니다.  
   6. 복합 대입 연산자 또한 가능합니다. (+=, -=, \*=, /=, %=, >>=, <<= 등등..)

# 단순 대입 연산자 오버로딩
>> 자세한 설명은 [여기](https://github.com/Nighthom/Files/blob/main/Study/C++/%EB%B3%B5%EC%82%AC%20%EC%83%9D%EC%84%B1%EC%9E%90/readme.md#%EB%8B%A8%EC%88%9C-%EB%8C%80%EC%9E%85-%EC%97%B0%EC%82%B0%EC%9E%90-%EA%B3%BC-shallow-copy)로  
