# 함수 호출 규약(Calling Convention)


## 32bit OS용 호출 규약
>> 32bit OS는 주로 스택을 활용해서 인자를 전달합니다.  
>> 스택은 스택 프레임구조를 형성해서 관리하고,  
>> 함수가 반환될때 인자와 함께 정리합니다.  
>> 리턴 값은 eax 레지스터를 통해 전달합니다.  

### stdcall
```C
__stdcall int add(int a, int b) { return a + b; }
```
>> C언어에서 \_\_stdcall 키워드는 stdcall을 불러옵니다.  
>> stdcall은 바로 Callee에서 스택을 정리하는 방법으로,   
>> 위의 경우에서는 int형 변수 2개가 인자이므로   
>> ret 8 이런식으로 정리를 하겠네요.  
```ASM
push ebp                  // 스택 프레임 생성
mov ebp, esp
mov eax, DWORD PTR SS : [ebp-4]  ( int a )
mov ebx, DWORD PTR SS : [ebp-8]  ( int b )
add eax, ebx
leave
ret 8                     // 스택 정리!
```
### cdecl
>> cdecl은 c / c++에서의 기본 호출 규약입니다.  
>> \_\_cdcall 키워드를 붙여서 call할 수 있지만,  
>> 생략해도 똑같은 의미입니다.
>> caller에서 스택을 정리합니다. 가변 인자 함수를 호출할  
>> 수 있는데, 이유는 caller가 push할 인자의 갯수를 알고있기  
>> 때문에 정리도 할 수 있기 때문입니다.  
```C
__cdecl int sub(int a, int b);
int sub(int a, b);
```
>> 위 두 선언은 의미가 동일합니다! ( 32bit 환경에서)
```ASM
sub:
push ebp
mov ebp, esp
mov eax, DWORD PTR SS : [ebp-4]  ( int a )
mov ebx, DWORD PTR SS : [ebp-8]  ( int b )
sub eax, ebx
leave
retn

main:
...스택 프레임
call sub
add esp, 8          // 스택 정리! 
push eax
push "result : %d" 
call printf         // printf("result : %d, sub(a - b));
push 0
leave 
retn
```
>> 스택은 높은 메모리에서 낮은 메모리로 자라기 때문에,   
>> 현재 스택 위치를 변경해서 인자를 정리하려면 더해줘야 합니다.    
>> 이렇게 더해주면 다시 push할때 데이터를 덮어쓰겠죠?  

### fastcall
>> fastcall은 스택이 아닌 레지스터로 인자를 전달합니다.  
'''C
__fastcall int add(int a,int b);
'''
>> 첫 두 DWORD(4byte) 크기 이하의 인수는   
>> ecx, edx로 전달하는 방식입니다.   
>> 스택으로 전달되는 인자가 있다면,  
>> stdcall처럼 callee에서 정리합니다.  
