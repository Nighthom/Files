# 함수설계 원칙  

>> 함수로 선언해야 하는 요소는 다음과 같습니다.  

>>> 1. 기능을 함수로 묶어야 합니다.  
>>>> 최소단위로 잘게 잘게 쪼개서 함수를 만들어야 합니다.  
>>>> 이는 직관성을 위해서이기도 하지만, 함수를 유지보수하기   
>>>> 편하게 하기 위함이기도 합니다.  
```C
#include <stdio.h>
#include <conio.h>

#define MAX_FUNCTION_IN_MENU 4

int printArray(int* arr, int size);           // 에러가 아니면 0, 에러가 났을때 EOF 반환
int getMaxValue(int* arr, int size);          // 최댓값 반환
int getMinValue(int* arr, int size);          // 최솟값 반환
int Qsort(int* arr, int size);                // 에러가 아니면 0, 에러가 났을때 EOF 반환
int printMaxValue(int* arr, int size);        // 에러가 아니면 0, 에러가 났을때 EOF 반환
int printMinValue(int* arr, int size);        // 에러가 아니면 0, 에러가 났을때 EOF 반환

int (*menuFunc)(int*, int)[MAX_FUNCTION_IN_MENU] = 
{ printArray, printMaxValue, printMinValue, Qsort };      // 어떤 작업을 수행할지에 대한 LOOKUP TABLE.

int main() {
  int nData[] = { 3, 7, 5,  
                  8, 9, 0, 
                  20, 30, 40
                };                          // 초기 배열
  int options;
  int isErr;
  
  while((options = getch()) != 0) {
    RETURNPOINT:                                          // 예외처리 후 복귀할 위치
    printf("1. 배열 출력    2. 최댓값 출력  3. 최솟값 출력   4. 정렬하기   0. 종료\n\n");
    if(menuFunc[options](nData, sizeof(nData)/int) == EOF) {        // 예외처리
        goto ERROR;
    }
  }
  return 0;
  ERROR:
  에러 처리 루틴....
  goto RETURNPOINT;
}
```
>> 최댓값과 최솟값을 구하는 코드, 그리고 출력하는 코드를  
>> 분할해서 함수로 나타냈죠. 이런식으로 기능기능 함수를  
>> 쪼개면 좋습니다. 구현은 따로 하진 않았습니다만,   
>> 함수를 어떤 식으로 쪼갤지 미리 구성해두고 들어가면 좋아요.  
>> 위 코드에서는 룩업 배열을 활용하려고 일부러 좀 함수를 늘린 감이 있는데,  
>> 더 간결한 코드가 있으면 좋겠네요.  

## 함수의 이름
>> 함수의 이름은 그 함수의 기능을 직관적으로 보여주는 이름이어야 합니다.    
>> 그 누가 이 함수를 보더라도 이 함수는 어떤 기능을 가졌다!   
>> 이런 것들이 보여야겠죠. 위 코드를 보면 누가봐도   
>> 최댓값 출력, 구하기, 최솟값 구하기, 배열출력.. 이런것들을  
>> 명료하게 알 수 있죠.  
>> 그리고 위의 원칙과 상호 호환되는 원칙이 하나 더 있어요.  
>> 라이브러리를 만들어서 쓰거나, 
>> 협업할 때 중요한건데,    
>> 본인을 나타내는 짧은 문구(ex : 이니셜) 같은 것을    
>> 함수의 머리에 나타내면 좋습니다.    
```C
sjGetMaxValue;
```
>> 제가 예를들어서 getMaxValue라는 함수를 새로 디자인했는데,  
>> 다른 사람도 같은 이름의 함수를 만들었을 수도 있습니다.
>> sjGetMaxValue처럼 이름의 이니셜을 앞에 가져다 대면  
>> 간단하게 구분할 수 있겠죠?  
>> c++나 다른 언어에서는 namespace라는 기능이 있어  
>> 이를 활용할 수 있지만, C언어는 없으니 이런 요령?  
>> 이 중요합니다. 변수 이름에도 이런 팁은 이용 가능하겠죠?

## 두 줄 이상의 코드가 반복된다면 함수로 만들기를 고려하라.
>> 이거는 말할 것도 없죠?  
>> 함수를 만드는게 만들 때 더 편하기도 하거니와,  
>> 유지보수 할 경우 함수만 수정하면  
>> 반복되는 모든 코드를 다 수정할 수 있습니다.  

## 특정 기능이 다른 프로그램에서 활용될 가능성이 있다면 함수로 구현해라.
>> 함수로 구현해두면 다른 프로그램에서 활용할 때 이 함수를  
>> 라이브러리 형태로 가져오든지 복사해서 붙여넣던지 편하게  
>> 사용할 수 있을 겁니다.
>> 뭐.. 코드를 따로 가져와서 사용하는 방법도 있지만,  
>> 코드 찾기도 귀찮기도 하죠.

## 함수 내부에 여러가지 출력 기능을 넣지 말고, 반환값에 의미 부여하기.
>> 함수의 출력과 기능은 철저히 분리되어야 합니다.  
>> 이유는 무엇일까요? 이는 코드 재활용과 관련이 있습니다.  
>> 이 함수값을 출력하는데 이용할지, 아니면 다르게 이용할지는  
>> 모르는 일입니다. 그리고, 한글로 출력을 한다면  
>> 다른 언어 사용자들은 이 기능을 출력할 때 불편함을 겪겠죠.  
>> 위 코드는 출력 기능과 따로 구분했죠.  
>> 본론으로 돌아와서,   
>> 어떤 데이터를 여는 함수를 만들었을 때,   
>> 반환값이 -1 이면 데이터가 아예 없는 경우이고，    
>> -2 면 데이터가 있지만 이미 사용되고 있어서 열 수 
>> 없다는 경우로 나눌 수 있다면?     
>> 함수 외부에서 -1인 경우와 -2인 경우에 맞는 에러처리 루틴을  
>> 구현하면 되겠죠.  

## 매개 변수가 많다면 구조체로 전달할 것을 고려하기.   
>> 스택이 너무 커지면 좋은 구조라고 말하기 힘듭니다.    
>> 32bit os에서는 매개변수 전달에 대개 스택을 이용하기 때문에    
>> 스택 오버플로우가 빠르게 발생할 수 있어요.  
>> 64bit os에서는 함수 호출할 때 정수형 데이터는 6개까지,   
>> 실수형 데이터는 8개까지 레지스터로 전달하기 때문에  
>> 매개 변수가 많아지면 스택으로 전달해야되는 오버헤드가  
>> 발생하겠죠.   
>> 구조체의 포인터로 혹은 배열으로 한번에 데이터를 전달한다면?   
>> 매우 간단하게 매개변수를 줄이고, 스택 크기도 포인터 크기로   
>> 줄일 수 있는 방법입니다.  

## 함수의 정의 부분이 자신이 사용하는 편집기 기준으로 두페이지를 넘어간다면
## 함수를 분할할 것을 고려해라.
>> 함수를 문서로 생각하면 이 또한 매우 당연한 것이죠.    
>> 함수의 기능을 더 쪼갠 다음 순차적으로 호출하기만 하면 됩니다.  
>> 하나의 문서를 작성할 때 알아보기 좋게 문장을 끊고,    
>> 문단을 나눠서 나타내듯이,    
>> 함수 또한 사람이 보기 좋은 형태로 끊어서 나타내는 것이  
>> 좋은 선택이 될 수 있습니다.  

## 라이브러리를 만들 계획이라면, 함수 이름 앞에 전치사를 만들기.
>> 아까도 말했던 바 있죠?  
```C
sjGetMaxValue;
```
>> 와 같이 함수이름 앞에 전치사를 붙이면 누가 이 함수를  
>> 만들었는지 알기 편해지고, 함수의 중복 가능성이  
>> 줄어들겠죠?  
