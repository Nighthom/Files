# 자료형

> C언어에서는 자료형이 존재합니다. 
> short, int, long, long long 등 정수형 자료형,
> float, double, long double 등 실수형 자료형,
> 문자를 표현할 떄 쓰는 char(1바이트 정수),
> pointer을 기입하는 pointer 자료형 등등..
> 자료형은 하지만 메모리에 어떤식으로 데이터를 기입하고,
> 어떤식으로 데이터를 읽을 지에 대한 방법에 불과합니다.
> integer형 변수를 double형 변수를 읽듯 읽을 수도 있는것이죠.
> 이런 심각한 논리 오류를 야기하지 않도록 주의해야 합니다.

## 정수형 자료

**char, short, int, long, long long** -> 각각 1, 2, 4, 4/8, 8byte  (32bit / 64bit)  

## 실수형 자료


**float, double, long double** -> 각각 4, 8, 12/16byte (32bit / 64bit)  

## 포인터

>> 모든 자료형의 Pointer은 32bit에서는 4바이트,
>> 64bit에서는 8바이트의 크기를 갖습니다.
>> 주소에 사용하는 bit수가 다르기 떄문입니다.
>> void형 포인터 변수 또한 동일합니다.
>> 포인터형 자료형에 +1을 하면 sizeof(pointer)만큼 증가합니다.

## signed, unsigned

>> signed 변수는 부호가 있는 변수,
>> unsigned 변수는 부호가 없는 변수입니다.
>> 부호가 있는 변수는 2의 보수를 이용하여 음수를 나타냅니다.
>> 2의 보수는 해당 값에 not 연산을 실행하고, 
>> 1을 더하여 계산합니다.
>> ex ) 00000101 ( 5 )
>> not 연산 가하면 11111010
>> 1 더해서 11111011 ( -5 )
>> 위의 5와 -5를 더하면 1 00000000
>> 즉, 1byte로 표기할 수 없는 9번째 비트까지 caryy가 발생합니다.
>> 9바이트째 carry를 버려서 0이 나와요.
>> 비슷한 논리로 뺄셈할 때는 4 - 6을 한다고 가정했을때,
>> 6에 2의 보수를 취하고 더합니다.
>> 그러면 -2에 해당하는 11111101 이 나오게 됩니다.
>> <br>
>> signed 변수의 맨 앞 비트는 MSB(Most Significant Bit)
>> 라고 해서 부호를 판별하는 비트입니다.
>> unsigned 변수는 부호가 없습니다.
>> 따라서 음수, 양수가 존재하지 않으므로 
>> 맨 앞 비트까지 양수로 표기가 가능합니다. 

## 심볼릭 상수, 리터럴 상수
>> 심볼릭 상수는 사용자가 직접 지정해준, 즉 
>> 이름이 있는 상수입니다. 
>> 심볼릭 상수를 정의하는 법은.. 
>> 변수 정의문에서 const만 붙이면 됩니다.
>> const type name = value(원하는 값);
>> 아니면 전처리기로 정의해도 됩니다.
>> #define SYMBOLIC value(원하는 값)
>> 리터럴 상수는 누가 봐도 명백히 상수인 상수입니다.
>> 1, 1.0, 1.0f, 1s, 1.0lld, 'C', "Hello World" 등...
>> 이런식으로 위치를 나타내는 것이 아니라 값 그 자체를
>> 의미하는 키워드를 전부 리터럴 상수라고 합니다.
>> 상수 값은 전부 R-Value(Right-Value)입니다. 따라서, 
>> L-Value(Left, Locator)가 필요한 연산은 수행할 수 없습니다.
>> 대표적으로, 대입 연산이 있겠네요.


## 변수
>> 변수는 변화할 수 있는 수를 의미합니다.
>> 이 변수는 L-Value로 대입연산의 대상이 될 수 있기 때문에, 
>> 이 값은 언제던지 변화할 수 있습니다.
>> 
>> 조금 더 엄밀하게 정의하자면, 
>> 변수는 메모리 주소를 가리키는 포인터를 가지고 있고
>> 그 포인터를 이름(identifier)으로 bind합니다. 
>> 이 이름으로 변수는 그 메모리에 접근 / 쓰기 / 
>> 읽기 연산 등을 수행할 수 있습니다.

## 배열
>> 배열이라는 것은 연속된 공간에 나열된
>> 동일한 자료형의 변수 집합입니다.
```C
   int array[30];
```
>> 이런 식으로 선언하면 int형 변수 30개를
>> 한번에 선언한 것과 같은 결과를 얻을 수 있죠.
>> 배열 각각 변수에는 인덱스를 통해서 접근합니다.
>> 원소가 n개인 배열은 0~n-1 범위의 인덱스를 갖습니다.
>> 배열 그 자체의 값은 배열 포인터라는 특수한 자료형을
>> 갖습니다. 위 배열의 자료형은 
``` C
  int[30] 
```
>> 입니다. 크기는 int\*30입니다. 
>> pointer의 크기는 항상 주소값의 크기와 같아요.

## 문자열
>> 문자열은 문자 상수들의 배열입니다.
```
  'H' 는 문자, "Hello World"는 문자열.
```
>> 데이터 상으로 보면 연속된 자료에 
>> 문자들이 나열되어 있고, 마지막 문자의 뒤에
>> \0(terminate null(ASCII : 00)) 이 붙습니다.
>> 배열에 문자열을 저장해보고 직접 조회하거나, 
>> 메모리를 직접 들여다보면 명확히 알 수 있습니다.

[이전 페이지](https://github.com/Nighthom/Files/blob/main/Study/C/lesson/%EA%B8%B0%EB%B3%B8%EC%9D%B4%EB%A1%A0/%EC%98%88%EC%95%BD%EC%96%B4.md)  
[목차로 돌아가기](https://github.com/Nighthom/Files/tree/main/Study/C/lesson/%EA%B8%B0%EB%B3%B8%EC%9D%B4%EB%A1%A0)  
[다음 페이지](https://github.com/Nighthom/Files/blob/main/Study/C/lesson/%EA%B8%B0%EB%B3%B8%EC%9D%B4%EB%A1%A0/%EB%A9%94%EB%AA%A8%EB%A6%AC.md)
