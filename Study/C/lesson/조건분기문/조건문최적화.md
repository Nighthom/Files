# 조건문 최적화
코드 리팩토링을 할 경우 if else문과 switch 분기문은 어지간해서  
수정의 대상이 됩니다. 

만약 선형적인 비교를 조건으로 수행할 경우  
이중 if문을 사용해서 코드를 반으로 나누는게 좋은 선택일 수 있습니다.  

예를 들자면, 
```C
if(nPrice < 1000) {
  ...
  본문1
  ...
}
else if (nPrice < 1500) {
  ...
  본문2
  ...
}
else if (nPrice > 1700) {
  ...
  본문3
  ...
}
else { // 1700 > nPrice > 1500
  ...
  본문4
  ...
}
```
>> 만약 이런코드라면 
```C
if(nPrice < 1500) {
  if(nPrice < 1000) {
    ...
    본문1
    ...
  } 
  else {
    ...
    본문2
    ...
  }
}
else {
  if(nPrice > 1700) {
    ...
    본문3
    ...
  }
  else {
    ...
    본문4
    ...
  }
}
```
>> 이와 같이 수정하면 동치 연산이지만   
>> 연산 수행횟수를 효과적으로 줄일 수 있습니다.  
>> 조건 연산횟수가 3회 나올 수 있는 프로그램보다는,  
>> 무조건 2회 연산인 프로그램의 안정성이 좋겠죠.  
>> 하지만 특정히 많이 나오는 분기가 존재한다면  
>> 쇼트 서킷을 이용해서 이득을 보는게 더 좋을수도 있겠죠?  

# Lookup Table(룩업 배열)  
룩업 테이블은 매우 간단한 개념입니다.  

if ~ else문 및 switch ~ case문을 보통 이용한다면   
어떠한 조건에 맞는 값이 존재할 때 / 어떤 조건에 맞는   
케이스에 맞춰서 분기를 실행하게 됩니다.  

하지만, 필요한 연산을 미리 수행해서 배열안에 저장해놓고  
이를 인덱스값으로 가져오는 식으로 조건 계산을 하지 않아도    
원하는 결과를 얻어올 수 있습니다.  

### ex) 나이를 기반으로 3세 미만은 할인율 90%,  
>>  5세 미만은 할인율 80%,   
>>  7세 미만은 할인율 65%,  
>>  11세 미만은 할인률 30%로,  
>>  그이상은 100% 받는다고 치면  
>>  1세 미만인 예외와(잘못입력했다고 처리)  
>>  11세 이상인 경우를 조건분기시키고,  
>>  나머지 값은 배열의 인덱스에 맞춰서 배열에 넣는겁니다.  
```C 
  double nRate[10] {
    0.9, 0.9,           // 1 ~ 2세 90%
    0.8, 0.8,           // 3 ~ 4세 80%
    0.65, 0.65,         // 5 ~ 6세 65%
    0.3, 0.3, 0.3, 0.3  // 7 ~ 10세 30%
  }
```
>> 이런식으로 변화율을 인덱싱해놓으면 조건분기 없이도    
>> 값을 구할 수 있겠죠?    
>> 메모리는 좀더 쓰겠지만요.    
### ex2) 함수 포인터를 활용하는 방법도 있습니다.  
>> switch ~ case문을 활용해서 어떠한 조건에 따라   
>> 특정한 함수를 수행하게 만드는 경우,   
>> 예를들어 1번 조건이 나오면 덧셈,  
>> 2번 조건이 나오면 뺼셈,  
>> 3번 조건이 나오면 곱셈,  
>> 4번 조건이 나오면 나눗셈을 실행하는  
>> 사칙연산 프로그램이라고 칩시다.  
>> 만약 스위치문으로 구성한다면 입력받는 값과  
>> 동등비교연산을 4회나 수행해야 합니다.  
>> 하지만 입력받는 값을   
>> 함수 포인터로 인덱싱한다면?  
>> 예를 들어볼까요?
```C  
  int add(int a, b);  
```
>> 처럼 sub, mul, div 함수를 만들었다면  
```C
  int \*func(int a,b)[4] = { add, sub, mul, div };  
```
>> 이런식으로 함수 포인터에 함수들을 넣고  
>> 1, 2, 3, 4 입력받고 바로 인덱스를 이용해서  
>> 연산을 진행한다면 동등비교연산 안해도 되겠죠?  
>> 이런식으로 최적화를 진행합니다.  
   
     
