# 배열의 활용

>> 배열을 활용하는 방법은 정말 무수히 많아요.    
>> 여러 가지 변수를 한번에 선언할 수 있기때문에    
>> 그리고 그 오버헤드도 비슷한 자료에 비해     
>> 지극히 작기 때문에    
>> (예로 연결 리스트는 초기화에 데이터를 동적으로     
>> 할당받고, next노드에 다음 리스트를 연결해주는    
>> 생성시 오버헤드와 접근시 포인터연산을 추가로 해야하는  
>> 오버헤드가 발생합니다.)    
>> (그리고 동적 할당을 통해 공간을 할당하면  
>> 공간을 할당하고 해제하는 그 자체가 오버헤드입니다.)  

>> 배열은 선언과 초기화면 사용 준비 끝이에요! 
>> 또, 접근도 단순히 인덱스로 접근하면 바로바로 가능하죠.
>> 공간을 처음 선언한 크기에서 변경 불가능하기에  
>> 공간을 낭비할 수 있다는 단점이 있지만,  
>> 그 무엇보다 빠른 구조입니다.  

# 이진 트리
>> 이진 트리의 일반적인 구현은 연결 리스트로 하는 편이지만, 
>> 위에 말한 연산의 오버헤드때문에 속도는 느려요.
>> 트리는 배열을 선언하고
'''C
int tree[100];
'''
>> 처럼 선언을 했다면 트리에     
>> 레벨순회 한대로 인덱스를 붙입니다.   
'''C
트리에서 자식 노드에 접근하려면  
자신의 인덱스*2+1 를하면 왼쪽 자식노드, 
자신의 인덱스*2+2 를하면 오른쪽 자식노드에 접근 가능합니다.
'''
>> 만약 트리가 비어있는 공간이 있다면 메모리 낭비가 심하겠죠?   
>> 완전 이진트리를 구현할 때는 낭비가 없기에  
>> 많이 쓰는 방법이에요.  

# Lookup 배열
>> 이에 대한 설명은
[Lookup 배열](https://github.com/Nighthom/Files/blob/main/Study/C/lesson/%EC%A1%B0%EA%B1%B4%EB%B6%84%EA%B8%B0%EB%AC%B8/%EC%A1%B0%EA%B1%B4%EB%AC%B8%EC%B5%9C%EC%A0%81%ED%99%94.md#lookup-table%EB%A3%A9%EC%97%85-%EB%B0%B0%EC%97%B4)  
>> 로 이동해주세요!  

# 인덱스 순차접근시 보수법 취하기  
>> 어떤 배열에 접근할 때 순차적으로 접근하다가도    
>> 다음에는 역순으로 접근해야 할 때가 있습니다.  
>> 이럴 때 조건문 1개 반복문 두 개를 쓰는게 아니라    
>> 반복문 안에 조건을 마련해놓고 특정 조건을 만족하면  
'''C
arr[sizeof(arr) - i];
'''
>> 이렇게 접근하면 역순으로 접근할 수 있어요!
