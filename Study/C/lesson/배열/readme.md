# 배열

>> 배열은 변수들의 집합체라고 이해하면 편합니다.
```C 
int arr[10];
```
>> 배열은 type name[length]; 이런식으로 선언합니다.  
>> 배열의 이름인 arr은 배열의 원소인 arr[0]의 포인터값과  
>> 동일한 값을 갖고 있습니다.   
>> 이 배열은 길이가 10이므로 arr[0] ~ arr[9]까지의 범위를  
>> 갖습니다. int형 배열이므로 arr[0]과 arr[1]은   
>> 포인터가 int형 크기인 4만큼 떨어져 있지요.  


# 배열과 포인터
>> 배열은 엄밀히 말해서 배열 포인터 상수라고 말하면 좋습니다.  
>> 배열 포인터 상수를 배열 연산자를 통해서 주소에 직접 접근하는거라고  
>> 봐도 무방하죠. 포인터 변수도 배열 연산자를 통해 인덱스 n을 입력하면,  
>> 해당 포인터로부터 n * size만큼 떨어진 주소의 값을 참조할 수 있습니다.  
>> 배열은 포인터이기에 앞서 상수이기에 다른 값을 대입하는것은 불가능합니다.  
>> 배열의 각 원소는 변수이지만, 배열 포인터는 R-Value입니다.  
>> 마지막으로, 일반적인 포인터와 다르게 배열 포인터의 크기는
>> 배열 원소 갯수 * 자료형 크기입니다. 위에 입력한 배열은  
>> int[10]의 타입을 갖는다고 봐야겠죠.  
>> sizeof(arr) = int * 10 = 40.   
>> 하지만 포인터 변수는 sizeof 연산을 수행했을때  
>> 포인터의 크기만 반환받습니다. 포인터와는 자료형이 비슷하지만 다릅니다.  


# 배열의 선언시 길이 생략 기능
>> 우선 예문을 볼까요?  
```C
char arr[] = "Array is nothing.";
```
>> 해당 문자열은 17+1의 크기를 갖고있습니다.  
>> 문자의 갯수는 17개지만, 문자열의 마지막에는  
>> \0(0x00) 문자가 붙기 때문이죠.   
>> 이런 식으로 배열의 초기화를 할 때   
>> 넣을 요소의 갯수가 명확하다면 배열의 길이를  
>> 생략할 수 있습니다.  
>> 포인터도 비슷하게 선언할 수 있습니다.  
```C
char* ptr = "Array is nothing.";
```
>> 설명을 덧붙이자면,  
>> 문자열 자체도 배열이기때문에 R-Value여도  
>> 포인터에 저장할 수는 있습니다.  
>> 하지만, sizeof(ptr) 연산을 했을때   
>> 배열처럼 18byte를 반환하는게 아니라   
>> 포인터의 크기를 반환한다는 사실에 유의하셔야 합니다.  

# 배열을 통해 원소들을 조작할 때 주의해야 할 사항
>> 배열은 선언할 때의 길이만큼의 메모리만을   
>> 부여받습니다.  
>> 배열의 크기가 늘어나거나 줄어드는 일은 일어나지 않아요.  
>> 따라서, 배열을 사용할 때는 그 길이를 넘어서는 참조를  
>> 하지 않으려고 노력해야 합니다.  
>> 가장 자주하는 실수는, 길이가 10인 배열에 접근할 때  
>> 인덱스를 10으로 입력하는겁니다.  
```C
int arr[10] = { 0 };
arr[10] = 1;
```
>> 해당 구문은 배열의 범위인 arr[9]를 넘어서는  
>> 참조를 수행하고 있습니다.  
>> 즉, 다른 변수의 영역을 침범해 매우 중요한  
>> 오류를 야기할 수 있는 코드인 셈이죠.  
>> 길이를 원하는만큼 늘리고 줄이고 싶다면  
>> 포인터 변수에 malloc이나 realloc, calloc 등을   
>> 이용해서 가변 데이터를 운영체제로부터 할당받아야 합니다.  
>> 그것도 아니라면, 연결 리스트를 활용해서 메모리를  
>> 동적으로 할당하고, 순차적으로 접근하는 논리적인 자료구조를  
>> 만드는것이 좋아요.  
